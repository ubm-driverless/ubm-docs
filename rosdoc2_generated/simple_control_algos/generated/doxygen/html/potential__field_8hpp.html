<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple_control_algos: include/potential_field.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple_control_algos
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">Package for simple control algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">potential_field.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for potential field-based reactive algorithm. The algorithm is based on the article: "A Real-Time Obstacle Avoidance Method for Autonomous Vehicles Using an Obstacle-Dependent Gaussian Potential Field" <a href="https://doi.org/10.1155/2018/5041401">https://doi.org/10.1155/2018/5041401</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="utils_8hpp.html">utils.hpp</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for potential_field.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="potential__field_8hpp__incl.png" border="0" usemap="#include_2potential__field_8hpp" alt=""/></div>
<map name="include_2potential__field_8hpp" id="include_2potential__field_8hpp">
<area shape="rect" title="Header file for potential field&#45;based reactive algorithm. The algorithm is based on the article: &quot;A R..." alt="" coords="267,5,461,32"/>
<area shape="rect" href="utils_8hpp.html" title="Utility functions for mathematical calculations and basic operations." alt="" coords="286,80,365,107"/>
<area shape="rect" title=" " alt="" coords="5,155,91,181"/>
<area shape="rect" title=" " alt="" coords="115,155,178,181"/>
<area shape="rect" title=" " alt="" coords="381,155,467,181"/>
<area shape="rect" title=" " alt="" coords="491,155,551,181"/>
<area shape="rect" title=" " alt="" coords="575,155,638,181"/>
<area shape="rect" title=" " alt="" coords="281,155,356,181"/>
<area shape="rect" title=" " alt="" coords="202,155,257,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="potential__field_8hpp__dep__incl.png" border="0" usemap="#include_2potential__field_8hppdep" alt=""/></div>
<map name="include_2potential__field_8hppdep" id="include_2potential__field_8hppdep">
<area shape="rect" title="Header file for potential field&#45;based reactive algorithm. The algorithm is based on the article: &quot;A R..." alt="" coords="90,5,285,32"/>
<area shape="rect" href="potential__field__node_8hpp.html" title="Defines the PotentialFieldNode class that creates a reactive algorithm based on potential fields...." alt="" coords="5,80,172,121"/>
<area shape="rect" href="potential__pursuit__node_8hpp.html" title="Defines the PotentialPursuitNode class that creates a reactive algorithm based on potential fields...." alt="" coords="196,80,379,121"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an obstacle with its properties. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a71f0c0cfaeac67efc260987375b06050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a71f0c0cfaeac67efc260987375b06050">reduce_lidar_fov</a> (std::vector&lt; float &gt; &amp;ranges, int ranges_to_remove)</td></tr>
<tr class="memdesc:a71f0c0cfaeac67efc260987375b06050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocesses LiDAR data by removing a specified number of range values from the beginning and end of the vector.  <a href="potential__field_8hpp.html#a71f0c0cfaeac67efc260987375b06050">More...</a><br /></td></tr>
<tr class="separator:a71f0c0cfaeac67efc260987375b06050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4be497bdcc23caa0ab2fd575915ba0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a2d4be497bdcc23caa0ab2fd575915ba0">find_obstacles</a> (const std::vector&lt; float &gt; &amp;ranges, float obstacle_threshold_gain, float hysteresis, float inverse_res, float car_width)</td></tr>
<tr class="memdesc:a2d4be497bdcc23caa0ab2fd575915ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies and returns a list of obstacles based on range data.  <a href="potential__field_8hpp.html#a2d4be497bdcc23caa0ab2fd575915ba0">More...</a><br /></td></tr>
<tr class="separator:a2d4be497bdcc23caa0ab2fd575915ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabda3256be7b08b8e746b28d18cdd374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#aabda3256be7b08b8e746b28d18cdd374">calculate_obstacle_parameters</a> (const std::vector&lt; float &gt; &amp;ranges, <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a> &amp;obstacle, float inverse_res, float car_width)</td></tr>
<tr class="memdesc:aabda3256be7b08b8e746b28d18cdd374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the parameters of an obstacle based on range data.  <a href="potential__field_8hpp.html#aabda3256be7b08b8e746b28d18cdd374">More...</a><br /></td></tr>
<tr class="separator:aabda3256be7b08b8e746b28d18cdd374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803813ac89e8048584b04e919455f5df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a803813ac89e8048584b04e919455f5df">compute_obstacle_potential</a> (const std::vector&lt; <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a> &gt; &amp;obstacles_list, int field_size, float field_resolution)</td></tr>
<tr class="memdesc:a803813ac89e8048584b04e919455f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the potential field generated by a list of obstacles.  <a href="potential__field_8hpp.html#a803813ac89e8048584b04e919455f5df">More...</a><br /></td></tr>
<tr class="separator:a803813ac89e8048584b04e919455f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60300b3e5373b56171efdb41435d35ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a60300b3e5373b56171efdb41435d35ee">max_index</a> (const std::vector&lt; float &gt; &amp;ranges, float inverse_res, float field_resolution)</td></tr>
<tr class="memdesc:a60300b3e5373b56171efdb41435d35ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the maximum value in a vector of ranges and scales it.  <a href="potential__field_8hpp.html#a60300b3e5373b56171efdb41435d35ee">More...</a><br /></td></tr>
<tr class="separator:a60300b3e5373b56171efdb41435d35ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c06f14481d9674434dfba4c96df16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#aad9c06f14481d9674434dfba4c96df16">compute_attractive_potential</a> (std::vector&lt; float &gt; &amp;repulsive_field, int attractive_index, float attractive_power)</td></tr>
<tr class="memdesc:aad9c06f14481d9674434dfba4c96df16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and adds the attractive potential to the repulsive field.  <a href="potential__field_8hpp.html#aad9c06f14481d9674434dfba4c96df16">More...</a><br /></td></tr>
<tr class="separator:aad9c06f14481d9674434dfba4c96df16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfec49a1ed55be5be4a39ad99afea84"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned short int, float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a3bfec49a1ed55be5be4a39ad99afea84">find_local_minima</a> (const std::vector&lt; float &gt; &amp;vec, bool include_global_minima)</td></tr>
<tr class="memdesc:a3bfec49a1ed55be5be4a39ad99afea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the local minima in a given vector of floats.  <a href="potential__field_8hpp.html#a3bfec49a1ed55be5be4a39ad99afea84">More...</a><br /></td></tr>
<tr class="separator:a3bfec49a1ed55be5be4a39ad99afea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977a357ef5623917ae2dbb7d71c540a5"><td class="memItemLeft" align="right" valign="top">unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a977a357ef5623917ae2dbb7d71c540a5">compute_choosen_index</a> (unsigned short int attractive_index, const std::vector&lt; std::pair&lt; unsigned short int, float &gt;&gt; &amp;local_minima, bool use_minima_near_attractive)</td></tr>
<tr class="memdesc:a977a357ef5623917ae2dbb7d71c540a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the chosen index based on the attractive index and local minima.  <a href="potential__field_8hpp.html#a977a357ef5623917ae2dbb7d71c540a5">More...</a><br /></td></tr>
<tr class="separator:a977a357ef5623917ae2dbb7d71c540a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b22fce713a12c10d65d6e211afd221f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#a8b22fce713a12c10d65d6e211afd221f">potential_field_steering</a> (std::vector&lt; float &gt; ranges, float angle_increment, float desired_fov, float field_resolution, float obstacle_threshold_gain, float hysteresis, float attractive_power, float car_width, float max_steering_angle, float steering_gain, bool include_global_minima, bool use_minima_near_attractive)</td></tr>
<tr class="memdesc:a8b22fce713a12c10d65d6e211afd221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the steering angle using a potential field method based on LIDAR data.  <a href="potential__field_8hpp.html#a8b22fce713a12c10d65d6e211afd221f">More...</a><br /></td></tr>
<tr class="separator:a8b22fce713a12c10d65d6e211afd221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3f04ff98d2a27e8e515906313fed04"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="potential__field_8hpp.html#aac3f04ff98d2a27e8e515906313fed04">potential_pursuit_steering</a> (std::vector&lt; float &gt; ranges, float angle_increment, float desired_fov, float field_resolution, float obstacle_threshold_gain, float hysteresis, float attractive_power, float car_width, float max_steering_angle, float steering_gain, float max_distance_weight, float steering_error, bool include_global_minima, bool use_minima_near_attractive)</td></tr>
<tr class="memdesc:aac3f04ff98d2a27e8e515906313fed04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the steering angle using a potential field method based on LIDAR data.  <a href="potential__field_8hpp.html#aac3f04ff98d2a27e8e515906313fed04">More...</a><br /></td></tr>
<tr class="separator:aac3f04ff98d2a27e8e515906313fed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for potential field-based reactive algorithm. The algorithm is based on the article: "A Real-Time Obstacle Avoidance Method for Autonomous Vehicles Using an Obstacle-Dependent Gaussian Potential Field" <a href="https://doi.org/10.1155/2018/5041401">https://doi.org/10.1155/2018/5041401</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aabda3256be7b08b8e746b28d18cdd374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabda3256be7b08b8e746b28d18cdd374">&#9670;&nbsp;</a></span>calculate_obstacle_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_obstacle_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a> &amp;&#160;</td>
          <td class="paramname"><em>obstacle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inverse_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>car_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the parameters of an obstacle based on range data. </p>
<p>This function computes various parameters of an obstacle detected by find_obstacles function. These parameters include the angular width, central angular position, average distance, Gaussian spread parameter (sigma), adjusted distance (distance_tilda), and amplitude coefficient (coeff_a).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A vector of float values representing the range data from the sensor. </td></tr>
    <tr><td class="paramname">obstacle</td><td>A reference to an <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html" title="Represents an obstacle with its properties.">Obstacle</a> object where the calculated parameters will be stored. </td></tr>
    <tr><td class="paramname">inverse_res</td><td>A float value representing the inverse of the sensor's angular resolution [1/deg]. </td></tr>
    <tr><td class="paramname">car_width</td><td>A float value representing the width of the car. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad9c06f14481d9674434dfba4c96df16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9c06f14481d9674434dfba4c96df16">&#9670;&nbsp;</a></span>compute_attractive_potential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_attractive_potential </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>repulsive_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attractive_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>attractive_power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and adds the attractive potential to the repulsive field. </p>
<p>This function modifies the given repulsive field by adding an attractive potential to each element. The attractive potential is computed as a linear function of the distance to the attractive index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repulsive_field</td><td>A reference to a vector of floats representing the repulsive field. </td></tr>
    <tr><td class="paramname">attractive_index</td><td>An integer representing the index of the attractive point. </td></tr>
    <tr><td class="paramname">attractive_power</td><td>A float representing the strength of the attractive potential. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977a357ef5623917ae2dbb7d71c540a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977a357ef5623917ae2dbb7d71c540a5">&#9670;&nbsp;</a></span>compute_choosen_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short int compute_choosen_index </td>
          <td>(</td>
          <td class="paramtype">unsigned short int&#160;</td>
          <td class="paramname"><em>attractive_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; unsigned short int, float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_minima</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_minima_near_attractive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the chosen index based on the attractive index and local minima. </p>
<p>This function selects an index based on the given attractive index and a list of local minima. It can either choose the closest local minima to the attractive index or the global minimum based on the user's preference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attractive_index</td><td>The index that is considered attractive. </td></tr>
    <tr><td class="paramname">local_minima</td><td>A vector of pairs where each pair consists of an index and its corresponding value. </td></tr>
    <tr><td class="paramname">use_minima_near_attractive</td><td>A boolean flag indicating whether to use the closest local minima to the attractive index. If true, the closest local minima to the attractive index is chosen. If false, the global minimum is chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The chosen index based on the given criteria. </dd></dl>

</div>
</div>
<a id="a803813ac89e8048584b04e919455f5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803813ac89e8048584b04e919455f5df">&#9670;&nbsp;</a></span>compute_obstacle_potential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; compute_obstacle_potential </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacles_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>field_resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the potential field generated by a list of obstacles. </p>
<p>This function calculates the potential field for a given list of obstacles. Each obstacle contributes to the potential field using a Gaussian distribution. The resulting potential field is normalized to have a maximum value of 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obstacles_list</td><td>A vector of <a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html" title="Represents an obstacle with its properties.">Obstacle</a> objects representing the obstacles. </td></tr>
    <tr><td class="paramname">field_size</td><td>The size of the potential field (number of discrete angles). </td></tr>
    <tr><td class="paramname">field_resolution</td><td>The resolution of the field in degrees per index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of floats representing the computed potential field. </dd></dl>

</div>
</div>
<a id="a3bfec49a1ed55be5be4a39ad99afea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfec49a1ed55be5be4a39ad99afea84">&#9670;&nbsp;</a></span>find_local_minima()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned short int, float&gt; &gt; find_local_minima </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_global_minima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the local minima in a given vector of floats. </p>
<p>This function iterates through the input vector and identifies the local minima, which are elements that are smaller than their immediate neighbors. Optionally, it can also include the global minimum in the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The input vector of floats to search for local minima. </td></tr>
    <tr><td class="paramname">include_global_minima</td><td>A boolean flag indicating whether to include the global minimum in the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs, where each pair contains the index and value of a local minimum. </dd></dl>

</div>
</div>
<a id="a2d4be497bdcc23caa0ab2fd575915ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4be497bdcc23caa0ab2fd575915ba0">&#9670;&nbsp;</a></span>find_obstacles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="elRef" href="http://docs.ros.org/en/latest/p/detector_cpp/generated/doxygen/html/classObstacle.html">Obstacle</a>&gt; find_obstacles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>obstacle_threshold_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hysteresis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inverse_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>car_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies and returns a list of obstacles based on range data. </p>
<p>This function processes a vector of range data to detect obstacles. It uses a threshold to determine the presence of obstacles and applies hysteresis to avoid noise. The function can use either a fixed threshold or a dynamically calculated threshold based on the mean of the range data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A vector of float values representing the range data. </td></tr>
    <tr><td class="paramname">obstacle_threshold_gain</td><td>Gain factor for dynamic threshold calculation. </td></tr>
    <tr><td class="paramname">hysteresis</td><td>Hysteresis value to avoid noise in obstacle detection. </td></tr>
    <tr><td class="paramname">inverse_res</td><td>Inverse of the proportionality constant for obstacle width calculation [1/deg]. </td></tr>
    <tr><td class="paramname">car_width</td><td>Width of the car for obstacle width calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Obstacle&gt; A vector of detected obstacles. </dd></dl>

</div>
</div>
<a id="a60300b3e5373b56171efdb41435d35ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60300b3e5373b56171efdb41435d35ee">&#9670;&nbsp;</a></span>max_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max_index </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inverse_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>field_resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index of the maximum value in a vector of ranges and scales it. </p>
<p>This function iterates through a vector of float values (ranges) to find the index of the maximum value. It then scales this index to find the corresponding inside the field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A vector of float values representing the ranges. </td></tr>
    <tr><td class="paramname">inverse_res</td><td>A float value representig the inverse of the ranges resolution [1/deg]. </td></tr>
    <tr><td class="paramname">field_resolution</td><td>A float value representing the resolution of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled index of the maximum value in the ranges vector. </dd></dl>

</div>
</div>
<a id="a8b22fce713a12c10d65d6e211afd221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b22fce713a12c10d65d6e211afd221f">&#9670;&nbsp;</a></span>potential_field_steering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float potential_field_steering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>field_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>obstacle_threshold_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hysteresis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>attractive_power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>car_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_steering_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>steering_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_global_minima</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_minima_near_attractive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the steering angle using a potential field method based on LIDAR data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A reference to a vector of float values representing LIDAR range measurements. </td></tr>
    <tr><td class="paramname">angle_increment</td><td>The angular resolution of the LIDAR in radians [rad]. </td></tr>
    <tr><td class="paramname">desired_fov</td><td>The angle in degrees of the wanted LIDAR field of view [deg]. </td></tr>
    <tr><td class="paramname">field_resolution</td><td>The resolution of the potential field in degrees. </td></tr>
    <tr><td class="paramname">obstacle_threshold_gain</td><td>The gain factor for the obstacle detection threshold. </td></tr>
    <tr><td class="paramname">hysteresis</td><td>The hysteresis value for obstacle detection. </td></tr>
    <tr><td class="paramname">attractive_power</td><td>The power of the attractive potential field. </td></tr>
    <tr><td class="paramname">car_width</td><td>The width of the car in meters. </td></tr>
    <tr><td class="paramname">max_steering_angle</td><td>The maximum allowable steering angle in radians. </td></tr>
    <tr><td class="paramname">steering_gain</td><td>The gain factor for the steering angle. </td></tr>
    <tr><td class="paramname">include_global_minima</td><td>A boolean flag to include global minima in the potential field. </td></tr>
    <tr><td class="paramname">use_minima_near_attractive</td><td>A boolean flag to use minima near the attractive potential. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed steering angle in radians. </dd></dl>

</div>
</div>
<a id="aac3f04ff98d2a27e8e515906313fed04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3f04ff98d2a27e8e515906313fed04">&#9670;&nbsp;</a></span>potential_pursuit_steering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float potential_pursuit_steering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>field_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>obstacle_threshold_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hysteresis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>attractive_power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>car_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_steering_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>steering_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>steering_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_global_minima</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_minima_near_attractive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the steering angle using a potential field method based on LIDAR data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A reference to a vector of float values representing LIDAR range measurements. </td></tr>
    <tr><td class="paramname">angle_increment</td><td>The angular resolution of the LIDAR in radians [rad]. </td></tr>
    <tr><td class="paramname">desired_fov</td><td>The angle in degrees of the wanted LIDAR field of view [deg]. </td></tr>
    <tr><td class="paramname">field_resolution</td><td>The resolution of the potential field in degrees. </td></tr>
    <tr><td class="paramname">obstacle_threshold_gain</td><td>The gain factor for the obstacle detection threshold. </td></tr>
    <tr><td class="paramname">hysteresis</td><td>The hysteresis value for obstacle detection. </td></tr>
    <tr><td class="paramname">attractive_power</td><td>The power of the attractive potential field. </td></tr>
    <tr><td class="paramname">car_width</td><td>The width of the car in meters. </td></tr>
    <tr><td class="paramname">max_steering_angle</td><td>The maximum allowable steering angle in radians. </td></tr>
    <tr><td class="paramname">steering_gain</td><td>The gain factor for the steering angle. </td></tr>
    <tr><td class="paramname">max_distance_weight</td><td>The maximum weight for the distance in the potential field. </td></tr>
    <tr><td class="paramname">steering_error</td><td>The error in the steering angle computation. </td></tr>
    <tr><td class="paramname">include_global_minima</td><td>A boolean flag to include global minima in the potential field. </td></tr>
    <tr><td class="paramname">use_minima_near_attractive</td><td>A boolean flag to use minima near the attractive potential. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed steering angle in radians. </dd></dl>

</div>
</div>
<a id="a71f0c0cfaeac67efc260987375b06050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f0c0cfaeac67efc260987375b06050">&#9670;&nbsp;</a></span>reduce_lidar_fov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reduce_lidar_fov </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ranges_to_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preprocesses LiDAR data by removing a specified number of range values from the beginning and end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>A reference to a vector of float values representing LiDAR range data. </td></tr>
    <tr><td class="paramname">ranges_to_remove</td><td>The number of range values to remove from both the beginning and end of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
